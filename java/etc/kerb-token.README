             ==== Kerberos Token Extension ====

== Kerberos token extension
This extension allows 3rd party token(jwt) can be used to authenticate to Kerberos and obtain a ticket granting ticket.
It bases on Kerberos preauth framework(FAST tunnel) and provides another preauthent method similar to OTP and PKINIT. 

It supports two modes:

1) token-as-credential

This mode allows token can be used as credential to authenticate to KDC for a normal principal instead of user password
or key. When using the token to request a tgt, the user name claimed in the token must match the specified Kerberos principal.

2) token-as-principal

This mode allows token can be used to request tgt and service tickets in the name of a configured proxy Kerberos principal, 
and such the user name in asserted in the token is different from the principal. The principal only serves as a proxy and 
provides a secure channel for the token to services. In service side, it should authenticate and authorize the token, not
the principal. For service that doesn't understand this token extension, the tickets in the scheme should be rejected.

We consider to support this mode to work together with anonymous PKINIT, and then the above mentioned proxy Kerberos principal 
can be avoided, since the anonymous principal can be used. 
WELLKNOWN/ANONYMOUS@WELLKNOWN:ANONYMOUS

1. Deployment

1) This assumes you have a jwt token authority and provider, and you can provide its certificate with decryption key and 
verification key to validate the tokens it issues.
  
2) It provides jwt-token module(so file) and implements both client side and kdc side corresponding plugins to make it work.
To deploy, on both KDC host and client hosts:

cp jwt.so /usr/local/lib/krb5/plugins/preauth/
jwt-token.so  otp.so  pkinit.so

2. Configuration

1) In KDC side, in kdc.conf:

In token-preauth section,

token-for-realms: <REALM1, REALM2, ...>

token-authority-cert: <TOKEN-AUTHORITY-CERTIFICATE-FLE>

or equivalently

token-decryption-key: <TOKEN-DECRYPTION-KEY-FILE>

token-verification-key: <TOKEN-VERIFICATION-KEY-FILE>

allow-token-as-credential: <true/false>
token-principal-mapping: <TOKEN-ATTRIBUTE_FOR_USERNAME>

allow-token-as-principal: <true/false>
token-as-principal: <PROXY-PRINCIPAL-FOR-TOKEN-USERS-REALM1, ...>

2) In client side

No.

3 Optionally, PKINIT

You can deploy and configure PKINIT to meet the armor key requirements very easily for client. Like OTP, token should be
protected from leakage in the FAST tunnel between client and KDC, which requres an armor ticket or key. The options to
get a FAST armor key:
1) Sticking a srvtab in etc
2) Use PKINIT, supposedly anonymous PKINIT
3) Get a TGT for an "ordinary" user with a long-term shared secret

4. How to use

1) Assumes you have a token;

2) Get an armor tgt assuming you use anonymous PKINIT option

kinit -c /tmp/krb5cc_armor -n @<YOUR_REALM>

3) Get tgt using your token, like

kinit -T /tmp/krb5cc_armor_token -c /tmp/krb5cc_my -X token=<YOUR-JWT-TOKEN> <YOUR-PRINCIPAL>

Note, if you want the token-as-principal behavior, YOUR-PRINCIPAL should be the well-known token proxy principal that's
configured in KDC side.

We provide a shell command to wraps all the above steps, like tokeninit:

tokeninit <YOUR-TOKEN> [YOUR-PRINCIPAL]

4) With the credential cached tgt, you can access services as normal.

== JAVA 

1. How to extract tokens in application server side
 
There're two APIs provided by JRE to utilize Kerberos mechanism. In both, we need to hook and extract the token from
service ticket so that
a. authenticate client with the token
b. extract identity attributes and labels from token for fine-grained  authorization.

1) GSSAPI

It's very simple, since JRE GSSAPI has already support to query info like authorization data from tickets. What we need
is to query and extract the authorization data from tickets, then decoding it(ASN.1) and get the token from it.

2) SASL

SASL GSSAPI mechanism wraps GSSAPI level but it doesn't support for now to expose the GSSContext outside thus we won't
able to do above using the mechanism. We need to come up our own SASL mechanism like GSSAPI but allow application to 
access the needed GSSContext to do above for querying and extracting tokens.

2. A new JAAS login module: KerbTokenAuthnLoginModule

This module can be configured and get token from token cache, then does the whole work the following:

1) Get needed armor ticket/key;
2) kinit with the armor ticket and token, gets tgt and puts it in specified credentail cache;
3) Wraps and exectues Krb5LoginModule with above credential cache;
4) As a result of 3), all necessary credential is validated and put in JAVA authorization context.
